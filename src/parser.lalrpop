use lalrpop_util::ParseError;
use crate::{
    ast::{
        Function,
        Type,
        Block,
        Statement,
        Expr,
        Data,
        Visibility,
        TypeObjectField,
        Interface,
        FunctionSignature,
        Parameters,
        Parameter,
        MethodType,
        AnonFunctionSignature,
        AnonFunction,
        TypeDef,
        VarDef,
        VarAssign,
    },
    lexer::{
        Token,
        Location,
        Keyword,
    },
    ErrorLevel,
    Error,
    parse_char,
};


grammar<'input>(filename:&'input str);


extern {
    type Location=Location;
    type Error=crate::Error<'input,&'static str>;
    enum Token<'input> {
        "fn"=>Token::Keyword(Keyword::Function),
        "type"=>Token::Keyword(Keyword::Type),
        "interface"=>Token::Keyword(Keyword::Interface),
        "pub"=>Token::Keyword(Keyword::Pub),
        "mut"=>Token::Keyword(Keyword::Mut),
        "impl"=>Token::Keyword(Keyword::Impl),
        "import"=>Token::Keyword(Keyword::Import),
        "for"=>Token::Keyword(Keyword::For),
        "while"=>Token::Keyword(Keyword::While),
        "loop"=>Token::Keyword(Keyword::Loop),
        "break"=>Token::Keyword(Keyword::Break),
        "return"=>Token::Keyword(Keyword::Return),
        "continue"=>Token::Keyword(Keyword::Continue),
        "match"=>Token::Keyword(Keyword::Match),
        "enum"=>Token::Keyword(Keyword::Enum),
        "module"=>Token::Keyword(Keyword::Module),
        "this"=>Token::Keyword(Keyword::This),
        "Word"=>Token::Word(<&'input str>),
        ","=>Token::Comma,
        ":"=>Token::Colon,
        "::"=>Token::Associated,
        ";"=>Token::SemiColon,
        "("=>Token::ParenthesisStart,
        ")"=>Token::ParenthesisEnd,
        "["=>Token::BracketStart,
        "]"=>Token::BracketEnd,
        "{"=>Token::BraceStart,
        "}"=>Token::BraceEnd,
        ":="=>Token::Decl,
        ">="=>Token::GreaterEqual,
        ">"=>Token::Greater,
        "<="=>Token::LessEqual,
        "<"=>Token::Less,
        "=="=>Token::Equal,
        "!="=>Token::NotEqual,
        "="=>Token::Assign,
        "-"=>Token::Dash,
        "."=>Token::Dot,
        "..."=>Token::Etc,
        "|"=>Token::Union,
        "+"=>Token::Add,
        "*"=>Token::Mul,
        "/"=>Token::Div,
        "%"=>Token::Mod,
        "&"=>Token::And,
        "!"=>Token::Not,
        "'"=>Token::SingleQuote,
        "\\"=>Token::Backslash,
        "String"=>Token::String(<&'input str>),
        "Newline"=>Token::Newline,
        "Number"=>Token::Number(<&'input str>),
        "Float"=>Token::Float(<&'input str>),
        "DocComment"=>Token::DocComment(<&'input str>),
    }
}


pub All:Vec<Statement<'input>>={
    <BlockInner*>,
    <BlockInner*> SkipNewline,
};


AnonFunctionSignature:AnonFunctionSignature<'input>={
    "fn" <params:Parameters> <ret_type:(":" <TypeEnclosed>)?>=>AnonFunctionSignature {
        params,
        ret_type,
    },
};
AnonFunction:AnonFunction<'input>={
    <sig:AnonFunctionSignature> <block:Block>=>sig.to_function(block),
};
FunctionSignature:FunctionSignature<'input>={
    <public:Public?> "fn" <name:Word> <params:Parameters> <ret_type:(":" <Type>)?>=>FunctionSignature {
        public:public.into(),
        name,
        params,
        ret_type,
    },
};
Function:Function<'input>={
    <sig:FunctionSignature> <block:Block>=>sig.to_function(block),
};
Parameters:Parameters<'input>={
    "[" "]"=>Parameters::default(),
    "[" "this" <normal:("," <Parameter>)*> <var_arg:("," "..." <Parameter>)?> "]"=>Parameters {
        method_type:MethodType::This,
        normal,
        var_arg,
    },
    "[" "mut" "this" <normal:("," <Parameter>)*> <var_arg:("," "..." <Parameter>)?> "]"=>Parameters {
        method_type:MethodType::ThisMut,
        normal,
        var_arg,
    },
    "[" <normal:(<Parameter> ",")*> <last:Parameter> <var_arg:("," "..." <Parameter>)?> "]"=>{
        let mut normal=normal;
        normal.push(last);
        return Parameters {
            method_type:MethodType::None,
            normal,
            var_arg,
        };
    },
};
Parameter:Parameter<'input>={
    "mut" <name:Word> ":" <ty:Type>=>Parameter{mutable:true,name,ty},
    <name:Word> ":" <ty:Type>=>Parameter{mutable:false,name,ty},
};
Type:Type<'input>=<FunctionType>;
FunctionType:Type<'input>={
    <sig:AnonFunctionSignature>=>Type::FunctionSig(Box::new(sig)),
    <CompositeType>,
};
CompositeType:Type<'input>={
    <tys:(<UnionType> "+")+> <last:UnionType>=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Composite(tys);
    },
    <UnionType>,
};
UnionType:Type<'input>={
    <tys:(<TypeInner> "|")+> <last:TypeInner>=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Union(tys);
    },
    <TypeInner>,
};
TypeInner:Type<'input>={
    <TypeInnerGeneric>,
    "(" <FunctionType> ")",
};
TypeEnclosed:Type<'input>=<FunctionTypeEnclosed>;
FunctionTypeEnclosed:Type<'input>={
    <sig:AnonFunctionSignature>=>Type::FunctionSig(Box::new(sig)),
    <CompositeTypeEnclosed>,
};
CompositeTypeEnclosed:Type<'input>={
    "(" <tys:(<UnionTypeEnclosed> "+")+> <last:UnionTypeEnclosed> ")"=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Composite(tys);
    },
    <UnionTypeEnclosed>,
};
UnionTypeEnclosed:Type<'input>={
    "(" <tys:(<TypeInnerEnclosed> "|")+> <last:TypeInnerEnclosed> ")"=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Union(tys);
    },
    <TypeInnerEnclosed>,
};
TypeInnerEnclosed:Type<'input>={
    <TypeInnerGeneric>,
    "(" <FunctionTypeEnclosed> ")",
};
TypeInnerGeneric:Type<'input>={
    <name:Word>=>{
        match name {
            "Uint"=>Type::Uint,
            "Int"=>Type::Int,
            "Float"=>Type::Float,
            "DoubleFloat"=>Type::DoubleFloat,
            "Byte"=>Type::Byte,
            "Char"=>Type::Char,
            "String"=>Type::String,
            _=>Type::Named{name,generics:Vec::new()},
        }
    },
    <start:@L> <name:Word> "(" <first:CompositeType> ")" <end:@R>=>?{
        match name {
            "Uint"|"Int"|"Float"|"DoubleFloat"|"Byte"|"Char"|"String"=>Err(ParseError::User{error:Error {
                start,
                end,
                filename,
                level:ErrorLevel::ParseError,
                reason:"builtin types cannot have generics",
            }}),
            _=>Ok(Type::Named{name,generics:vec![first]}),
        }
    },
    <name:Word> "(" <tys:(<CompositeType> ",")+> <last:CompositeType> ")"=>{
        let mut generics=tys;
        generics.push(last);
        return Type::Named{name,generics};
    },
    "{" SkipNewline? <fields:(<TypeObjectField> ObjectFieldEnd+)+> <last:TypeObjectField?> "}"=>{
        let mut fields=fields;
        if let Some(last)=last {
            fields.push(last);
        }
        return Type::Object{fields,exact:false};
    },
    "{" SkipNewline? <fields:(<TypeObjectField> ObjectFieldEnd+)+> <last:TypeObjectField?> "..." SkipNewline? "}"=>{
        let mut fields=fields;
        if let Some(last)=last {
            fields.push(last);
        }
        return Type::Object{fields,exact:true};
    },
};
Block:Block<'input>={
    "{" "}"=>Block::new(),
    "{" SkipNewline "}"=>Block::new(),
    "{" <BlockInner+> "}",
    "{" <BlockInner+> SkipNewline "}",
};
BlockInner:Statement<'input>={
    SkipNewline <Statement>,
    <Statement>,
};
Statement:Statement<'input>={
    <f:Function>=>Statement::FunctionDef(f),
    <sig:FunctionSignature> StatementEnd=>Statement::FunctionSig(sig),
    <i:Interface>=>Statement::InterfaceDef(i),
    <expr:Expr> StatementEnd=>Statement::Expr(expr),
    <type_def:TypeDef> StatementEnd=>Statement::TypeDef(type_def),
    <var:VarDef> StatementEnd=>Statement::VarDef(var),
    <assign:VarAssign> StatementEnd=>Statement::VarAssign(assign),
    <"DocComment">=>Statement::Doc(<>),
};
Expr:Expr<'input>={
    <MethodCall>,
    <FunctionCall>,
    <AssociatedPath>,
    <FieldPath>,
    <Var>,
    <function:AnonFunction>=>Expr::AnonFunction(function),
    <l:Expr> "&" <r:Comparison>=>Expr::And(Box::new([l,r])),
    <l:Expr> "|" <r:Comparison>=>Expr::Or(Box::new([l,r])),
    "!" <l:Comparison>=>Expr::Not(Box::new(l)),
    //"{" <fields:(<Word> ":" <Expr> ObjectFieldEnd)+> "}"=>Expr::Object(fields),
    <Comparison>,
};
Comparison:Expr<'input>={
    <l:Comparison> "==" <r:Operand>=>Expr::Equal(Box::new([l,r])),
    <l:Comparison> "!=" <r:Operand>=>Expr::NotEqual(Box::new([l,r])),
    <l:Comparison> ">=" <r:Operand>=>Expr::GreaterEqual(Box::new([l,r])),
    <l:Comparison> "<=" <r:Operand>=>Expr::LessEqual(Box::new([l,r])),
    <l:Comparison> ">" <r:Operand>=>Expr::Greater(Box::new([l,r])),
    <l:Comparison> "<" <r:Operand>=>Expr::Less(Box::new([l,r])),
    <Operand>,
};
Operand:Expr<'input>={
    <l:Operand> "+" <r:Factor>=>Expr::Add(Box::new([l,r])),
    <l:Operand> "-" <r:Factor>=>Expr::Sub(Box::new([l,r])),
    <Factor>,
};
Factor:Expr<'input>={
    <l:Factor> "*" <r:Term>=>Expr::Mul(Box::new([l,r])),
    <l:Factor> "/" <r:Term>=>Expr::Div(Box::new([l,r])),
    <l:Factor> "%" <r:Term>=>Expr::Mod(Box::new([l,r])),
    <Term>,
};
Term:Expr<'input>={
    <s:String>=>Expr::Data(s),
    <c:Char>=>Expr::Data(c),
    <num:Number>=>Expr::Data(num),
    "-" <num:Number>=>Expr::Negate(Box::new(Expr::Data(num))),
    <num:Float>=>Expr::Data(num),
    "-" <num:Float>=>Expr::Negate(Box::new(Expr::Data(num))),
    <block:Block>=>Expr::Block(block),
    "(" <Expr> ")",
};
Public:Visibility={
    "pub" "(" <w:Word> ")"=>{
        // temporary workaround. Hopefully I can specify `Word("lib")`, but it depends on the generated parser code.
        match w {
            "lib"=>Visibility::Library,
            "local"=>Visibility::Local,
            _=>Visibility::Full,
        }
    },
    "pub"=>Visibility::Full,
};
Mutable:Visibility={
    "mut" "(" <w:Word> ")"=>{
        match w {
            "lib"=>Visibility::Library,
            "local"=>Visibility::Local,
            _=>Visibility::Full,
        }
    },
    "mut"=>Visibility::Full,
};
Interface:Interface<'input>={
    <public:Public?> "interface" <name:Word> <requirement:(":" <Type>)?> <block:Block>=>Interface {
        public:public.into(),
        name,
        requirement,
        block,
    },
};
TypeDef:TypeDef<'input>={
    <public:Public?> "type" <name:Word> "=" <ty:Type>=>TypeDef{public:public.into(),name,ty},
};
VarDef:VarDef<'input>={
    <public:Public?> <mutable:Mutable?> <name:Word> ":=" <data:Expr>=>VarDef{public:public.into(),mutable:mutable.into(),name,data:Some(data),ty:None},
    <public:Public?> <mutable:Mutable?> <name:Word> ":" <ty:Type> "=" <data:Expr>=>VarDef{public:public.into(),mutable:mutable.into(),name,data:Some(data),ty:Some(ty)},
    <public:Public?> <mutable:Mutable?> <name:Word> ":" <ty:Type>=>VarDef{public:public.into(),mutable:mutable.into(),name,data:None,ty:Some(ty)},
};
VarAssign:VarAssign<'input>=<name:Word> "=" <data:Expr>=>VarAssign{name,data};


TypeObjectField:TypeObjectField<'input>={
    <doc:"DocComment"?> <name:Word> ":" <ty:Type>=>TypeObjectField{public:Visibility::None,mutable:Visibility::None,name,ty,doc},
    <doc:"DocComment"?> <mutable:Mutable> <name:Word> ":" <ty:Type>=>TypeObjectField{public:Visibility::None,mutable,name,ty,doc},
    <doc:"DocComment"?> <public:Public> <name:Word> ":" <ty:Type>=>TypeObjectField{public,mutable:Visibility::None,name,ty,doc},
    <doc:"DocComment"?> <public:Public> <mutable:Mutable> <name:Word> ":" <ty:Type>=>TypeObjectField{public,mutable,name,ty,doc},
};
ObjectFieldEnd:()={
    ","=>(),
    "Newline"=>(),
};
String:Data<'input>="String"=>Data::String(<>.into());
Number:Data<'input>="Number"=>Data::GenericNumber(<>);
Float:Data<'input>="Float"=>Data::GenericFloat(<>);
Char:Data<'input>={
    "'" "\\" "'" "'"=>Data::Char('\''),
    "'" "\\" "\\" "'"=>Data::Char('\\'),
    <start:@L> "'" "\\" <num:"Number"> "'" <end:@R>=>?{
        if num!="0" {
            return Err(ParseError::User{error:Error {
                filename,
                start,
                end,
                level:ErrorLevel::ParseError,
                reason:"invalid escape sequence",
            }});
        }
        return Ok(Data::Char('\0'));
    },
    <start:@L> "'" "\\" <w:Word> "{" <n:"Number"> "}" "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        s.push('{');
        s.push_str(n);
        s.push('}');
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" "\\" <w:Word> "{" <hex:Word> "}" "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        s.push('{');
        s.push_str(hex);
        s.push('}');
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" "\\" <w:Word> "{" <n:"Number"> <hex:Word> "}" "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        s.push('{');
        s.push_str(n);
        s.push_str(hex);
        s.push('}');
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" "\\" <w:Word> "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" <w:Word> "'" <end:@R>=>?{
        return parse_char(w.to_string(),filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
};
Var:Expr<'input>=<name:Word>=>Expr::Var(name);
AssociatedPath:Expr<'input>=<first:Word> <path:AdditionalAssociated+>=>{
    let mut path=path;
    path.insert(0,first);
    return Expr::AssociatedPath(path);
};
AdditionalAssociated:&'input str="::" <Word>;
FieldPath:Expr<'input>=<from:Expr> "." <name:Word>=>Expr::FieldAccess{from:Box::new(from),name};
MethodCall:Expr<'input>={
    <from:Expr> "." <name:Word> "(" ")"=>Expr::MethodCall{
        from:Box::new(from),
        name,
        args:Vec::new()
    },
    <from:Expr> "." <name:Word> "(" <args:(<Expr> ObjectFieldEnd)*> <last:Expr> ObjectFieldEnd? ")"=>{
        let mut args=args;
        args.push(last);
        return Expr::MethodCall {
            from:Box::new(from),
            name,
            args,
        };
    },
};
FunctionCall:Expr<'input>={
    <name:Word> "(" ")"=>Expr::FunctionCall{name,args:Vec::new()},
    <name:Word> "(" <args:(<Expr> ObjectFieldEnd)*> <last:Expr> ObjectFieldEnd? ")"=>{
        let mut args=args;
        args.push(last);
        return Expr::FunctionCall {
            name,
            args,
        };
    },
};
AdditionalArg:Expr<'input>="," <Expr>;
SkipNewline:()="Newline"=>();
StatementEnd:()={
    "Newline"=>(),
    ";"+=>(),
};
Word:&'input str={
    "Word"=><>,
};
