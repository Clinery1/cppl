use lalrpop_util::ParseError;
use crate::{
    ast::{
        Function,
        Type,
        Block,
        Statement,
        Expr,
        Data,
        Visibility,
        TypeObjectField,
        Interface,
        FunctionSignature,
        Parameters,
        Parameter,
        MethodType,
        AnonFunctionSignature,
        AnonFunction,
        TypeDef,
        VarDef,
        VarAssign,
        ObjectField,
        Import,
        ConstVarDef,
        StaticVarDef,
        Match,
        MatchPattern,
        MatchPatternStructure,
        MatchPatternStructureItem,
        FunctionCall,
        Enum,
        TypeParameter,
        Impl,
    },
    lexer::{
        Token,
        Location,
    },
    ErrorLevel,
    Error,
    parse_char,
};


grammar<'input>(filename:&'input str);


extern {
    type Location=Location;
    type Error=crate::Error<'input,&'static str>;
    enum Token<'input> {
        "fn"=>Token::Keyword(crate::Keyword::Function),
        "type"=>Token::Keyword(crate::Keyword::Type),
        "interface"=>Token::Keyword(crate::Keyword::Interface),
        "pub"=>Token::Keyword(crate::Keyword::Pub),
        "mut"=>Token::Keyword(crate::Keyword::Mut),
        "impl"=>Token::Keyword(crate::Keyword::Impl),
        "import"=>Token::Keyword(crate::Keyword::Import),
        "for"=>Token::Keyword(crate::Keyword::For),
        "while"=>Token::Keyword(crate::Keyword::While),
        "loop"=>Token::Keyword(crate::Keyword::Loop),
        "return"=>Token::Keyword(crate::Keyword::Return),
        "continue"=>Token::Keyword(crate::Keyword::Continue),
        "match"=>Token::Keyword(crate::Keyword::Match),
        "enum"=>Token::Keyword(crate::Keyword::Enum),
        "module"=>Token::Keyword(crate::Keyword::Module),
        "this"=>Token::Keyword(crate::Keyword::This),
        "true"=>Token::Keyword(crate::Keyword::True),
        "false"=>Token::Keyword(crate::Keyword::False),
        "const"=>Token::Keyword(crate::Keyword::Const),
        "static"=>Token::Keyword(crate::Keyword::Static),
        "and"=>Token::Keyword(crate::Keyword::And),
        "or"=>Token::Keyword(crate::Keyword::Or),
        "in"=>Token::Keyword(crate::Keyword::In),
        "is"=>Token::Keyword(crate::Keyword::Is),
        "Word"=>Token::Word(<&'input str>),
        ","=>Token::Comma,
        ":"=>Token::Colon,
        "::"=>Token::Associated,
        ";"=>Token::SemiColon,
        "("=>Token::ParenthesisStart,
        ")"=>Token::ParenthesisEnd,
        "["=>Token::BracketStart,
        "]"=>Token::BracketEnd,
        "{"=>Token::BraceStart,
        "}"=>Token::BraceEnd,
        ":="=>Token::Decl,
        ">="=>Token::GreaterEqual,
        ">"=>Token::Greater,
        "<="=>Token::LessEqual,
        "<"=>Token::Less,
        "=="=>Token::Equal,
        "!="=>Token::NotEqual,
        "="=>Token::Assign,
        "-"=>Token::Dash,
        "."=>Token::Dot,
        "..."=>Token::Etc,
        "|"=>Token::Union,
        "+"=>Token::Add,
        "*"=>Token::Mul,
        "/"=>Token::Div,
        "%"=>Token::Mod,
        "&"=>Token::And,
        "!"=>Token::Not,
        "'"=>Token::SingleQuote,
        "\\"=>Token::Backslash,
        "=>"=>Token::MatchSeparator,
        "String"=>Token::String(<&'input str>),
        "Newline"=>Token::Newline,
        "Number"=>Token::Number(<&'input str>),
        "Float"=>Token::Float(<&'input str>),
    }
}


pub All:Vec<Statement<'input>>={
    <BlockInner*>,
    <BlockInner*> SkipNewline,
};


AnonFunctionSignature:AnonFunctionSignature<'input>={
    "fn" <params:Parameters> <ret_type:(":" <TypeEnclosed>)?>=>AnonFunctionSignature {
        params,
        ret_type,
    },
};
AnonFunction:AnonFunction<'input>={
    <sig:AnonFunctionSignature> <block:Block>=>sig.to_function(block),
};
FunctionSignature:FunctionSignature<'input>={
    <public:Public?> "fn" <name:Word> <params:Parameters> <ret_type:(":" <Type>)?>=>FunctionSignature {
        public,
        name,
        params,
        ret_type,
    },
};
Function:Function<'input>={
    <sig:FunctionSignature> <block:Block>=>sig.to_function(block),
};
Parameters:Parameters<'input>={
    "[" "]"=>Parameters::default(),
    "[" "this" <normal:("," <Parameter>)*> <var_arg:("," "..." <Parameter>)?> "]"=>Parameters {
        method_type:MethodType::This,
        normal,
        var_arg,
    },
    "[" "mut" "this" <normal:("," <Parameter>)*> <var_arg:("," "..." <Parameter>)?> "]"=>Parameters {
        method_type:MethodType::ThisMut,
        normal,
        var_arg,
    },
    "[" <normal:(<Parameter> ",")*> <last:Parameter> <var_arg:("," "..." <Parameter>)?> "]"=>{
        let mut normal=normal;
        normal.push(last);
        return Parameters {
            method_type:MethodType::None,
            normal,
            var_arg,
        };
    },
};
Parameter:Parameter<'input>={
    "mut" <name:Word> ":" <ty:Type>=>Parameter{mutable:true,name,ty},
    <name:Word> ":" <ty:Type>=>Parameter{mutable:false,name,ty},
};
TypeParameters:Vec<TypeParameter<'input>>={
    "[" "]"=>Vec::new(),
    "[" <params:(<TypeParameter> ",")*> <last:TypeParameter> ","? "]"=>{
        let mut params=params;
        params.push(last);
        return params;
    },
};
TypeParameter:TypeParameter<'input>=<name:Word> <ty:(":" <Type>)?>=>TypeParameter{name,ty};
Type:Type<'input>=<FunctionType>;
FunctionType:Type<'input>={
    <sig:AnonFunctionSignature>=>Type::FunctionSig(Box::new(sig)),
    <CompositeType>,
};
CompositeType:Type<'input>={
    <tys:(<UnionType> "+")+> <last:UnionType>=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Composite(tys);
    },
    <UnionType>,
};
UnionType:Type<'input>={
    <tys:(<TypeInner> "|")+> <last:TypeInner>=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Union(tys);
    },
    <TypeInner>,
};
TypeInner:Type<'input>={
    <TypeInnerGeneric>,
    "(" <FunctionType> ")",
};
TypeEnclosed:Type<'input>=<FunctionTypeEnclosed>;
FunctionTypeEnclosed:Type<'input>={
    <sig:AnonFunctionSignature>=>Type::FunctionSig(Box::new(sig)),
    <CompositeTypeEnclosed>,
};
CompositeTypeEnclosed:Type<'input>={
    "(" <tys:(<UnionTypeEnclosed> "+")+> <last:UnionTypeEnclosed> ")"=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Composite(tys);
    },
    <UnionTypeEnclosed>,
};
UnionTypeEnclosed:Type<'input>={
    "(" <tys:(<TypeInnerEnclosed> "|")+> <last:TypeInnerEnclosed> ")"=>{
        let mut tys=tys;
        tys.push(last);
        return Type::Union(tys);
    },
    <TypeInnerEnclosed>,
};
TypeInnerEnclosed:Type<'input>={
    <TypeInnerGeneric>,
    "(" <FunctionTypeEnclosed> ")",
};
TypeInnerGeneric:Type<'input>={
    <name:Word>=>{
        match name {
            "Uint"=>Type::Uint,
            "Int"=>Type::Int,
            "Float"=>Type::Float,
            "DoubleFloat"=>Type::DoubleFloat,
            "Byte"=>Type::Byte,
            "Bool"=>Type::Bool,
            "Char"=>Type::Char,
            "String"=>Type::String,
            "Never"=>Type::Never,
            _=>Type::Named{name,generics:Vec::new()},
        }
    },
    <start:@L> <name:Word> "(" <first:CompositeType> ")" <end:@R>=>?{
        match name {
            "Uint"|
            "Int"|
            "Float"|
            "DoubleFloat"|
            "Byte"|
            "Bool"|
            "Char"|
            "String"|
            "Never"=>Err(ParseError::User{error:Error {
                start,
                end,
                filename,
                level:ErrorLevel::ParseError,
                reason:"builtin types cannot have generics",
            }}),
            _=>Ok(Type::Named{name,generics:vec![first]}),
        }
    },
    <name:Word> "(" <tys:(<CompositeType> ",")+> <last:CompositeType> ")"=>{
        let mut generics=tys;
        generics.push(last);
        return Type::Named{name,generics};
    },
    "{" SkipNewline? <fields:(<TypeObjectField> ObjectFieldEnd+)+> <last:TypeObjectField?> "}"=>{
        let mut fields=fields;
        if let Some(last)=last {
            fields.push(last);
        }
        return Type::Object{fields,exact:false};
    },
    "{" SkipNewline? <fields:(<TypeObjectField> ObjectFieldEnd+)+> <last:TypeObjectField?> "..." SkipNewline? "}"=>{
        let mut fields=fields;
        if let Some(last)=last {
            fields.push(last);
        }
        return Type::Object{fields,exact:true};
    },
};
Block:Block<'input>={
    "{" "}"=>Block::new(),
    "{" SkipNewline "}"=>Block::new(),
    "{" <BlockInner+> "}",
    "{" <BlockInner+> SkipNewline "}",
};
BlockInner:Statement<'input>={
    SkipNewline <Statement>,
    <Statement>,
};
Statement:Statement<'input>={
    <f:Function>=>Statement::FunctionDef(f),
    <sig:FunctionSignature> StatementEnd=>Statement::FunctionSig(sig),
    <i:Interface>=>Statement::InterfaceDef(i),
    <expr:Expr> StatementEnd=>Statement::Expr(expr),
    <type_def:TypeDef> StatementEnd=>Statement::TypeDef(type_def),
    <var:VarDef> StatementEnd=>Statement::VarDef(var),
    <var:ConstVarDef> StatementEnd=>Statement::ConstVarDef(var),
    <var:StaticVarDef> StatementEnd=>Statement::StaticVarDef(var),
    <assign:VarAssign> StatementEnd=>Statement::VarAssign(assign),
    <e:Enum>=>Statement::Enum(e),
    <ImportStmt> StatementEnd,
    <Module> StatementEnd,
    <i:Impl>=>Statement::Impl(i),
};
Impl:Impl<'input>={
    "impl" <params:TypeParameters?> <for_ty:Type> <block:Block>=>Impl{params,interface:None,for_ty,block},
    "impl" <params:TypeParameters?> <interface:Type> "for" <for_ty:Type> <block:Block>=>Impl{params,interface:Some(interface),for_ty,block},
};
Module:Statement<'input>="module" <name:Word>=>Statement::Module(name);
Enum:Enum<'input>={
    <public:Public?> "enum" <name:Word> <params:TypeParameters?> "{" SkipNewline? <variants:(<Type> ObjectFieldEnd)*> <last:Type> ObjectFieldEnd? "}"=>{
        let mut variants=variants;
        variants.push(last);
        return Enum{public,name,params,variants};
    },
    <public:Public?> "enum" <name:Word> <params:TypeParameters?> "{" SkipNewline? "}"=>return Enum{public,name,params,variants:Vec::new()},
};
ImportStmt:Statement<'input>="import" <import:Import>=>Statement::Import(import);
Import:Import<'input>={
    <path:Word>=>Import::Path(vec![path]),
    <paths:(<Word> "::")+> <last:Word>=>{
        let mut paths=paths;
        paths.push(last);
        return Import::Path(paths);
    },
    <path:(<Word> "::")+> <block:ImportBlock>=>Import::PathBlock{path,block},
};
ImportBlock:Vec<Import<'input>>={
    "{" "}"=>Vec::new(),
    "{" SkipNewline? <imports:(<Import> ObjectFieldEnd)*> <last:Import> ObjectFieldEnd? "}"=>{
        let mut imports=imports;
        imports.push(last);
        return imports;
    },
};
Expr:Expr<'input>={
    "&" <r:BooleanOps>=>Expr::Ref(Box::new(r)),
    "&" "mut" <r:BooleanOps>=>Expr::RefMut(Box::new(r)),
    <path:AssociatedPath>=>Expr::AssociatedPath(path),
    <function:AnonFunction>=>Expr::AnonFunction(function),
    "!" <l:BooleanOps>=>Expr::Not(Box::new(l)),
    "{" <fields:(<ObjectField> ObjectFieldEnd)*> <last:ObjectField> ObjectFieldEnd? "}"=>{
        let mut fields=fields;
        fields.push(last);
        return Expr::ObjectCreation(fields);
    },
    <BooleanOps>,
};
BooleanOps:Expr<'input>={
    <l:BooleanOps> "and" <r:Comparison>=>Expr::And(Box::new([l,r])),
    <l:BooleanOps> "or" <r:Comparison>=>Expr::Or(Box::new([l,r])),
    <Comparison>,
};
Comparison:Expr<'input>={
    <l:Comparison> "==" <r:Operand>=>Expr::Equal(Box::new([l,r])),
    <l:Comparison> "!=" <r:Operand>=>Expr::NotEqual(Box::new([l,r])),
    <l:Comparison> ">=" <r:Operand>=>Expr::GreaterEqual(Box::new([l,r])),
    <l:Comparison> "<=" <r:Operand>=>Expr::LessEqual(Box::new([l,r])),
    <l:Comparison> ">" <r:Operand>=>Expr::Greater(Box::new([l,r])),
    <l:Comparison> "<" <r:Operand>=>Expr::Less(Box::new([l,r])),
    <l:Comparison> "is" <r:Type>=>Expr::IsType(Box::new(l),r),
    <Operand>,
};
Operand:Expr<'input>={
    <l:Operand> "+" <r:Factor>=>Expr::Add(Box::new([l,r])),
    <l:Operand> "-" <r:Factor>=>Expr::Sub(Box::new([l,r])),
    <Factor>,
};
Factor:Expr<'input>={
    <l:Factor> "*" <r:Term>=>Expr::Mul(Box::new([l,r])),
    <l:Factor> "/" <r:Term>=>Expr::Div(Box::new([l,r])),
    <l:Factor> "%" <r:Term>=>Expr::Mod(Box::new([l,r])),
    <CallPaths>,
};
CallPaths:Expr<'input>={
    <from:CallPaths> "." <name:Word> "(" ")"=>Expr::MethodCall{
        from:Box::new(from),
        name,
        args:Vec::new()
    },
    <from:CallPaths> "." <name:Word> "(" <args:(<Expr> ObjectFieldEnd)*> <last:Expr> ObjectFieldEnd? ")"=>{
        let mut args=args;
        args.push(last);
        return Expr::MethodCall {
            from:Box::new(from),
            name,
            args,
        };
    },
    <from:CallPaths> "." <name:Word>=>Expr::FieldAccess{from:Box::new(from),name},
    <f:FunctionCall>=>Expr::FunctionCall(f),
    <Term>,
};
Term:Expr<'input>={
    "this"=>Expr::Var("this"),
    <Var>,
    <d:Data>=>Expr::Data(d),
    <ExprStatements>,
};
ExprStatements:Expr<'input>={
    <block:Block>=>Expr::Block(block),
    <ForeverLoop>,
    <WhileLoop>,
    <ForLoop>,
    <m:Match>=>Expr::Match(Box::new(m)),
    "(" <Expr> ")",
};
Data:Data<'input>={
    <Bool>,
    <String>,
    <Char>,
    <Float>,
    <Number>,
};
MatchPattern:MatchPattern<'input>={
    <d:Data>=>MatchPattern::Data(d),
    <s:MatchPatternStructure>=>MatchPattern::Structure(s),
    "." <name:Word> "(" ")"=>MatchPattern::MethodCall{name,args:Vec::new()},
    "." <name:Word> "(" <args:(<Expr> ObjectFieldEnd)*> <last:Expr> ObjectFieldEnd? ")"=>{
        let mut args=args;
        args.push(last);
        return MatchPattern::MethodCall {
            name,
            args,
        };
    },
    <v:Word>=>MatchPattern::Var(v),
    "==" <r:Expr>=>MatchPattern::Equal(r),
    "!=" <r:Expr>=>MatchPattern::NotEqual(r),
    ">=" <r:Expr>=>MatchPattern::GreaterEqual(r),
    "<=" <r:Expr>=>MatchPattern::LessEqual(r),
    ">" <r:Expr>=>MatchPattern::Greater(r),
    "<" <r:Expr>=>MatchPattern::Less(r),
    "is" <r:Type>=>MatchPattern::IsType(r),
};
MatchPatternStructure:MatchPatternStructure<'input>={
    // exact, fields
    <type_name:Word> "{" <block:(<MatchPatternStructureItem> ObjectFieldEnd)*> <last:MatchPatternStructureItem> ObjectFieldEnd? "}"=>{
        let mut block=block;
        block.push(last);
        return MatchPatternStructure::TypedBlock{exact:true,type_name,block};
    },
    // inexact, fields
    <type_name:Word> "{" <block:(<MatchPatternStructureItem> ObjectFieldEnd)*> <last:MatchPatternStructureItem> ObjectFieldEnd "..." "}"=>{
        let mut block=block;
        block.push(last);
        return MatchPatternStructure::TypedBlock{exact:false,type_name,block};
    },
    // maybe exact, no fields
    <type_name:Word> "{" SkipNewline? <etc:"..."?> "}"=>{
        return MatchPatternStructure::TypedBlock{exact:etc.is_some(),type_name,block:Vec::new()};
    },
    // exact, fields
    "{" <block:(<MatchPatternStructureItem> ObjectFieldEnd)*> <last:MatchPatternStructureItem> ObjectFieldEnd? "}"=>{
        let mut block=block;
        block.push(last);
        return MatchPatternStructure::Block{exact:true,block};
    },
    // inexact, fields
    "{" <block:(<MatchPatternStructureItem> ObjectFieldEnd)*> <last:MatchPatternStructureItem> ObjectFieldEnd "..." "}"=>{
        let mut block=block;
        block.push(last);
        return MatchPatternStructure::Block{exact:false,block};
    },
    // maybe exact, no fields
    "{" SkipNewline? <etc:"..."?> "}"=>{
        return MatchPatternStructure::Block{exact:etc.is_some(),block:Vec::new()};
    },
};
MatchPatternStructureItem:MatchPatternStructureItem<'input>={
    <name:Word>=>MatchPatternStructureItem::Field(name),
    <name:Word> ":" <rename:Word>=>MatchPatternStructureItem::NamedField{name,rename},
    <name:Word> ":" <block:MatchPatternStructure>=>MatchPatternStructureItem::NamedBlock{name,block},
};
Match:Match<'input>={
    "match" <to_match:Expr> "{" SkipNewline? "}"=>Match{to_match,leafs:Vec::new()},
    "match" <to_match:Expr> "{" SkipNewline? <leafs:(<MatchPattern> "=>" <Expr> ObjectFieldEnd)*> <last:(<MatchPattern> "=>" <Expr>)> ObjectFieldEnd? "}"=>{
        let mut leafs=leafs;
        leafs.push(last);
        return Match{to_match,leafs};
    },
};
ForeverLoop:Expr<'input>="loop" <block:Block>=>Expr::ForeverLoop(block);
WhileLoop:Expr<'input>="while" <condition:Expr> <block:Block>=>Expr::WhileLoop{condition:Box::new(condition),block};
ForLoop:Expr<'input>="for" <var:Word> "in" <iterator:Expr> <block:Block>=>Expr::ForLoop{var,iterator:Box::new(iterator),block};
ObjectField:ObjectField<'input>={
    <public:Public?> <mutable:Mutable?> <name:Word> "=" <data:Expr>=>ObjectField{public,mutable,name,data},
    <public:Public?> <mutable:Mutable?> <name:Word>=>ObjectField{public,mutable,name,data:Expr::Var(name)},
};
Public:Visibility={
    "pub" "(" <Visibility> ")",
    "pub" "(" <l:@L> ")" <r:@R>=>?Err(ParseError::UnrecognizedToken{
        token:(l,Token::ParenthesisEnd,r),
        expected:vec![
            "\"lib\"".into(),
            "\"local\"".into(),
            "\"full\"".into()
        ],
    }),
    "pub"=>Visibility::Full,
};
Mutable:Visibility={
    "mut" "(" <Visibility> ")",
    "mut" "(" <l:@L> ")" <r:@R>=>?Err(ParseError::UnrecognizedToken{
        token:(l,Token::ParenthesisEnd,r),
        expected:vec![
            "\"lib\"".into(),
            "\"local\"".into(),
            "\"full\"".into()
        ],
    }),
    "mut"=>Visibility::Full,
};
Visibility:Visibility={
    <l:@L> <w:Word> <r:@R>=>?{
        match w {
            "lib"=>Ok(Visibility::Library),
            "local"=>Ok(Visibility::Local),
            "full"=>Ok(Visibility::Full),
            _=>Err(ParseError::UnrecognizedToken{token:(l,Token::Word(w),r),expected:vec!["\"lib\"".into(),"\"local\"".into(),"\"full\"".into()]}),
        }
    },
};
Interface:Interface<'input>={
    <public:Public?> "interface" <name:Word> <params:TypeParameters?> <requirement:(":" <Type>)?> <block:Block>=>Interface {
        public,
        name,
        params,
        requirement,
        block,
    },
};
TypeDef:TypeDef<'input>={
    <public:Public?> "type" <name:Word> <params:TypeParameters?> "=" <ty:Type>=>TypeDef{public,name,params,ty},
};
VarDef:VarDef<'input>={
    <public:Public?> <mutable:Mutable?> <name:Word> ":=" <data:Expr>=>VarDef{public,mutable,name,data:data,ty:None},
    <public:Public?> <mutable:Mutable?> <name:Word> ":" <ty:Type> "=" <data:Expr>=>VarDef{public,mutable,name,data:data,ty:Some(ty)},
};
ConstVarDef:ConstVarDef<'input>=<public:Public?> "const" <name:Word> ":" <ty:Type> "=" <data:Expr>=>ConstVarDef{public,name,data:data,ty:ty};
StaticVarDef:StaticVarDef<'input>=<public:Public?> "static" <mutable:Mutable?> <name:Word> ":" <ty:Type> "=" <data:Expr>=>StaticVarDef{public,mutable,name,data:data,ty:ty};
VarAssign:VarAssign<'input>=<name:Word> "=" <data:Expr>=>VarAssign{name,data};


TypeObjectField:TypeObjectField<'input>=<public:Public?> <mutable:Mutable?> <name:Word> ":" <ty:Type>=>TypeObjectField{public,mutable,name,ty};
ObjectFieldEnd:()={
    "," SkipNewline=>(),
    ","=>(),
};
String:Data<'input>="String"=>Data::String(<>.into());
Number:Data<'input>={
    "Number"=>Data::GenericNumber(false,<>),
    "-" <n:"Number">=>Data::GenericNumber(true,n),
};
Float:Data<'input>={
    "Float"=>Data::GenericFloat(false,<>),
    "-" <f:"Float">=>Data::GenericFloat(true,f),
};
Bool:Data<'input>={
    "true"=>Data::Bool(true),
    "false"=>Data::Bool(false),
};
Char:Data<'input>={
    "'" "\\" "'" "'"=>Data::Char('\''),
    "'" "\\" "\\" "'"=>Data::Char('\\'),
    <start:@L> "'" "\\" <num:"Number"> "'" <end:@R>=>?{
        if num!="0" {
            return Err(ParseError::User{error:Error {
                filename,
                start,
                end,
                level:ErrorLevel::ParseError,
                reason:"invalid escape sequence",
            }});
        }
        return Ok(Data::Char('\0'));
    },
    <start:@L> "'" "\\" <w:Word> "{" <n:"Number"> "}" "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        s.push('{');
        s.push_str(n);
        s.push('}');
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" "\\" <w:Word> "{" <hex:Word> "}" "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        s.push('{');
        s.push_str(hex);
        s.push('}');
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" "\\" <w:Word> "{" <n:"Number"> <hex:Word> "}" "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        s.push('{');
        s.push_str(n);
        s.push_str(hex);
        s.push('}');
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" "\\" <w:Word> "'" <end:@R>=>?{
        let mut s=String::with_capacity(w.len()+1);
        s.push('\\');
        s.push_str(w);
        return parse_char(s,filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
    <start:@L> "'" <w:Word> "'" <end:@R>=>?{
        return parse_char(w.to_string(),filename,start,end).map(Data::Char).map_err(|error|ParseError::User{error});
    },
};
Var:Expr<'input>=<name:Word>=>Expr::Var(name);
AssociatedPath:Vec<&'input str>=<first:Word> <path:AdditionalAssociated+>=>{
    let mut path=path;
    path.insert(0,first);
    return path;
};
AdditionalAssociated:&'input str="::" <Word>;
MethodCall:Expr<'input>={
};
FunctionCall:FunctionCall<'input>={
    <name:Word> "(" ")"=>FunctionCall{path:vec![name],args:Vec::new()},
    <name:Word> "(" <args:(<Expr> ObjectFieldEnd)*> <last:Expr> ObjectFieldEnd? ")"=>{
        let mut args=args;
        args.push(last);
        return FunctionCall {
            path:vec![name],
            args,
        };
    },
    <path:AssociatedPath> "(" ")"=>FunctionCall{path,args:Vec::new()},
    <path:AssociatedPath> "(" <args:(<Expr> ObjectFieldEnd)*> <last:Expr> ObjectFieldEnd? ")"=>{
        let mut args=args;
        args.push(last);
        return FunctionCall {
            path,
            args,
        };
    },
};
AdditionalArg:Expr<'input>="," <Expr>;
SkipNewline:()="Newline"=>();
StatementEnd:()={
    "Newline"=>(),
    ";"+=>(),
};
Word:&'input str={
    "Word"=><>,
};
